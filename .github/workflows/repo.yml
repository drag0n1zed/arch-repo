name: Build and Deploy Repo

# Allow the final deploying step to write
permissions:
  contents: write

# Run when..
on: 
  # ..a push happens
  push:
    branches: [main]
    paths:
      - 'packages/**'
      - 'index.html'
      - '.github/workflows/**'
  
  # ..the daily schedule happens
  schedule:
    - cron: '0 8 * * *'

  # ..manually triggered
  workflow_dispatch:

jobs:
  prep-matrix:
    runs-on: ubuntu-latest
    container: archlinux:latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Needed for git diff

      - name: Install Tools
        run: |
          pacman -Syu --noconfirm base-devel git jq

      - name: Create Build User
        run: |
          useradd -m builduser
          echo "builduser ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          chown -R builduser:builduser $PWD

      - name: Calculate Build Matrix
        id: set-matrix
        shell: bash
        env:
          # Using AtomGit for version comparison to ensure we don't rebuild 
          # packages that are already live on the mirror.
          AG_USER: "drag0n1zed"
          AG_REPO: "arch-repo" 
        run: |

          set -euo pipefail
          # config
          # Update URL to point to AtomGit Raw for version checking
          REPO_URL="https://atomgit.com/${AG_USER}/${AG_REPO}/raw/master"
          REPO_NAME="drags-repo"
          PACKAGE_ROOT="packages"
    
          # setup repo 
          echo "::group::Configuring Pacman for ${REPO_NAME}"
          # Configure pacman to use the custom repository for version comparison.
          # The '|| true' handles the case where the repo DB doesn't exist yet on the first run.
          printf "\n[%s]\nSigLevel = Optional TrustAll\nServer = %s\n" "$REPO_NAME" "$REPO_URL" | sudo tee -a /etc/pacman.conf
          sudo pacman -Sy --noconfirm || echo "::warning::Could not sync ${REPO_NAME} database. This is expected on the first run."
          echo "::endgroup::"
    
          # scan package
          TO_BUILD=()
          echo "Scanning for packages in '${PACKAGE_ROOT}' that require building..."
    
          for pkgbuild_path in "$PACKAGE_ROOT"/*/PKGBUILD; do
            pkg_dir=$(dirname "$pkgbuild_path")
      
            # generate .SRCINFO in a subshell to get dynamic version without downloading sources.
            # 'set -e' ensures the script fails immediately if makepkg encounters an error.
            srcinfo_output=$(cd "$pkg_dir" && sudo -u builduser makepkg --printsrcinfo)
    
            # parse name and version from the generated .SRCINFO
            pkg_name=$(awk -F ' = ' '/^\s*pkgname\s*=/ {print $2}' <<< "$srcinfo_output")
            full_new_ver=$(awk -F ' = ' '/^\s*pkgver\s*=/ {print $2}' <<< "$srcinfo_output")
    
            # query the repo DB for the currently published version, default to "0" if not found.
            repo_ver=$(pacman -Si "$pkg_name" 2>/dev/null | awk '/^Version/ {print $3}' || echo "0")
    
            echo "==> Checking ${pkg_name}: Repo [${repo_ver}] vs Local [${full_new_ver}]"
      
            # compare versions, add to queue if local version newer or package is new.
            if [[ "$repo_ver" == "0" ]]; then
              echo " -> New package. Adding to build queue."
              TO_BUILD+=("$pkg_dir")
            elif [[ $(vercmp "$full_new_ver" "$repo_ver") -gt 0 ]]; then
              echo " -> Update found. Adding to build queue."
              TO_BUILD+=("$pkg_dir")
            fi
          done
    
          # output
          if [ ${#TO_BUILD[@]} -eq 0 ]; then
            echo "::notice::No packages need to be built. The repository is up-to-date."
            echo "matrix=[]" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::Found ${#TO_BUILD[@]} package(s) to build."
            echo "The following packages will be added to the build matrix:"
            printf "  - %s\n" "${TO_BUILD[@]}"

            # Create a JSON array of package directories for the GitHub Actions matrix.
            json_matrix=$(printf '%s\n' "${TO_BUILD[@]}" | jq -R . | jq -sc)
            echo "matrix=${json_matrix}" >> "$GITHUB_OUTPUT"
          fi

  build:
    needs: prep-matrix
    # If prep-matrix returns empty list, prevents running
    if: ${{ needs.prep-matrix.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    container: archlinux:latest
    strategy:
      fail-fast: false # One failed package doesn't stop the rest
      matrix:
        package_path: ${{ fromJson(needs.prep-matrix.outputs.matrix) }}

    steps:
      - name: Prep environment
        run: |
          pacman -Syu --noconfirm base-devel git sudo

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create build user
        run: |
          useradd -m builduser
          # Passwordless sudo for the user
          echo "builduser ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          # Give ownership of the repo to the user
          chown -R builduser:builduser $PWD

      - name: Build ${{ matrix.package_path }}
        run: |
          echo "::group::Building ${{ matrix.package_path }}"
          cd "${{ matrix.package_path }}"
          # -s: install dependencies
          # -f: force a check
          # -c: clean up source files after build
          # Uses the builduser
          sudo -u builduser makepkg -sfc --noconfirm --force
          echo "::endgroup::"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-packages-${{ strategy.job-index }} # Unique names for each artifact
          path: ${{ matrix.package_path }}/*.pkg.tar.zst # Take only *.zst
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    container: archlinux:latest
    steps:
      - name: Prep environment
        # Added git-lfs for AtomGit huge file support
        run: |
          pacman -Syu --noconfirm base-devel git git-lfs openssh

      - name: Checkout repository
        # We need this to get your custom 'index.html'
        uses: actions/checkout@v4

      - name: Restore Existing DB from AtomGit
        env:
          AG_USER: "drag0n1zed"
          AG_REPO: "arch-repo" 
        continue-on-error: true
        run: |
          mkdir -p dist
          # Download from AtomGit Raw URL
          REPO_URL="https://atomgit.com/${AG_USER}/${AG_REPO}/raw/master"
          echo "Fetching existing DB from $REPO_URL" 
          
          # Download db.tar.zst and save as .db.tar.zst (repo-add requirement)
          curl -L -f -o dist/drags-repo.db.tar.zst "$REPO_URL/drags-repo.db.tar.zst" || echo "First run or DB missing."

      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: built-packages-*
          merge-multiple: true
          path: dist

      - name: Update pacman database
        run: |
          cd dist
          # Check if files actually exist
          if ls *.pkg.tar.zst 1> /dev/null 2>&1; then
            repo-add -n -R drags-repo.db.tar.zst *.pkg.tar.zst
          fi

          # Prepare flat files for raw serving
          rm -f drags-repo.db drags-repo.files
          # Copy real files to standard names so AtomGit raw URL serves them directly
          cp drags-repo.db.tar.zst drags-repo.db
          cp drags-repo.files.tar.zst drags-repo.files

      - name: Push to AtomGit (Orphan Force Push)
        env:
          AG_USER: "drag0n1zed"
          AG_TOKEN: ${{ secrets.ATOMGIT_TOKEN }}
          AG_REPO: "arch-repo" 
        run: |
          # 1. Move your custom index.html into the dist folder
          cp index.html dist/

          cd dist
          
          # 2. Initialize a fresh repo to keep history clean (using Github only as builder)
          git init
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
          git config --global --add safe.directory '*'

          # 3. Use LFS for the packages
          git lfs install
          git lfs track "*.pkg.tar.zst" "*.db" "*.files" "*.tar.zst"
          
          git add .
          git commit -m "Deploy Repo: $(date)"

          # 4. Force push to AtomGit Master
          git remote add atomgit "https://$AG_USER:$AG_TOKEN@atomgit.com/$AG_USER/$AG_REPO.git"
          git push -f atomgit master:master
